# capnp-build

A macro for building Cap'n Proto messages in Rust.

This crate provides a single macro, `capnp_build!`, which can be used to
construct Cap'n Proto messages. The macro takes a path to a
`Builder<'_>` type (as generated by capnpc) and a set of fields to set on that builder,
optionally with values to set them to.

The macro supports a variety of syntaxes for setting fields, including:

* Setting a primitive field to a value: `foo = 42`
* Setting a struct field to a nested message: `foo = { bar = 42, baz = 24 }`
* Setting a list field to a list of values: `foo = [1, 2, 3]`
* Setting a list field to a list of messages: `foo = [{ bar = 42 }, { baz = 24 }]`
* Setting a field to the result of a function call: `foo [ foo::init ] = 42`

## Example

Given the schema `foo.capnp`:

```capnp
struct ServiceMessage {
  id @0 :UInt64;
  message @1 :Data;
  userData @2 :Data;
}
```

The macro allows you to initialize the builder using

```rust
let id = 15;
let data = "my data";
let response_data: capnp::message::Builder<HeapAllocator> =
    capnp_build!(foo_capnp::service_message::Builder, {
        id = id,
        message = &[2, 3, 5, 7, 11, 13, 17, 19, 23],
        user_data = data.as_bytes(),
    });
```

The right side of the assignment `=` can be any expression, including function calls!

Nesting and unions (named and unnamed) are also possible:

```capnp
struct MessageFrame {
    id @0 :UInt64;
    :union {
        ok @1 :ServiceMessage;
        error @2 :Text;
    }
}
```

```rust
let id = 15;
let data = "my data";
let ok_response_data: capnp::message::Builder<HeapAllocator> =
    capnp_build!(foo_capnp::message_frame::Builder, {
        id = 2,
        ok = {
            id = id,
            message = &[2, 3, 5, 7, 11, 13, 17, 19, 23],
            user_data = data.as_bytes(),
        }
    });
let err_response_data: capnp::message::Builder<HeapAllocator> =
    capnp_build!(foo_capnp::message_frame::Builder, {
        id = 3,
        err = "Request failed",
    });
```

### Advanced Usage

Sometimes, it's more complicated than that. For example, you might want to store UUIDs, but Cap'n Proto doesn't have support for that data type (or even a primitive with the same size).

So, you can define your UUID like this:

```capnp
struct Uuid {
    low @0 :UInt64;
    high @1 :UInt64;
}
```

and then use it like this:

```capnp
struct ServiceMessage {
  id @0 :Uuid;
  message @1 :Data;
}
```

However, if you want to use the syntax of `capnp_build!` as explained above, it can quickly get cumbersome:

```rust
let uuid = Uuid::new_v4();
let (high, low) = uuid.as_u64_pair();
let response_data = capnp_build!(foo_capnp::service_message::Builder, {
    id = {
        low = low,
        high = high,
    },
    message = &[1,2,3],
});
```

So, there's a way to write functions that can be used within the macro:

```rust
fn build_uuid(uuid: uuid::Uuid, mut builder: foo_capnp::uuid::Builder) {
    let (high, low) = uuid.as_u64_pair();
    builder.set_low(low);
    builder.set_high(high);
}

fn foo() {
    let response_data = capnp_build!(foo_capnp::service_message::Builder, {
        id[build_uuid] = Uuid::new_v4(),
        message = &[1,2,3],
    });
}
```

The function is passed in with square brackets: `<field name>[<function name>] = <value>`. `<value>` is passed in as the first parameter and the builder as the second parameter. The Rust compiler takes care of checking types automatically.

## License

<sup>
Licensed under either of <a href="LICENSE-APACHE">Apache License, Version 2.0</a> or <a href="LICENSE-MIT">MIT license</a> at your option.
</sup>

<br>

<sub>
Unless you explicitly state otherwise, any contribution intentionally submitted for inclusion in this project by you, as defined in the Apache-2.0 license, shall be dual licensed as above, without any additional terms or conditions.
</sub>
